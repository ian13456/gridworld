<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />

    <title>Gridworld</title>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/three.js/108/three.min.js"
      integrity="sha256-3mBEX8I0uMLF7+AUjJeTCelosuorzYpqwBMBPDTyQqY="
      crossorigin="anonymous"
    ></script>
    <script src="lib/OrbitControls.js"></script>

    <style>
      body {
        margin: 0;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <script>
      const lol = 3200

      var camera, controls, scene, renderer
      init()
      //render(); // remove when using next line for animation loop (requestAnimationFrame)
      animate()
      function init() {
        scene = new THREE.Scene()
        scene.background = new THREE.Color(0xcccccc)
        scene.fog = new THREE.FogExp2(0xcccccc, 0.002)
        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)
        document.body.appendChild(renderer.domElement)
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000)
        camera.position.set(400, 200, 0)
        // controls
        controls = new THREE.OrbitControls(camera, renderer.domElement)
        //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
        controls.enableDamping = true // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05
        controls.screenSpacePanning = false
        controls.minDistance = 100
        controls.maxDistance = 500
        controls.maxPolarAngle = Math.PI / 2
        // world
        var leaves = new THREE.ConeBufferGeometry(10, 30, 64)
        var trunk = new THREE.CylinderBufferGeometry(3, 3, 10, 15)
        var leavesMat = new THREE.MeshPhongMaterial({ color: 0x008800, flatShading: true })
        var trunkMat = new THREE.MeshPhongMaterial({ color: 0xac7339, flatShading: true })
        for (var i = 0; i < 500; i++) {
          var leavesMesh = new THREE.Mesh(leaves, leavesMat)
          const x = Math.random() * lol - lol / 2
          const z = Math.random() * lol - lol / 2

          leavesMesh.position.x = x
          leavesMesh.position.y = 20
          leavesMesh.position.z = z
          leavesMesh.updateMatrix()
          leavesMesh.matrixAutoUpdate = false

          var trunkMesh = new THREE.Mesh(trunk, trunkMat)

          trunkMesh.position.x = x
          trunkMesh.position.y = 0
          trunkMesh.position.z = z
          trunkMesh.updateMatrix()
          trunkMesh.matrixAutoUpdate = false

          scene.add(leavesMesh)
          scene.add(trunkMesh)
        }
        // lights
        var light = new THREE.DirectionalLight(0xffffff)
        light.position.set(1, 1, 1)
        scene.add(light)
        var light = new THREE.DirectionalLight(0x002288)
        light.position.set(-1, -1, -1)
        scene.add(light)
        var light = new THREE.AmbientLight(0x222222)
        scene.add(light)
        //
        window.addEventListener('resize', onWindowResize, false)
      }
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      }
      function animate() {
        requestAnimationFrame(animate)
        controls.update() // only required if controls.enableDamping = true, or if controls.autoRotate = true
        render()
      }
      function render() {
        renderer.render(scene, camera)
      }
    </script>
  </body>
</html>
